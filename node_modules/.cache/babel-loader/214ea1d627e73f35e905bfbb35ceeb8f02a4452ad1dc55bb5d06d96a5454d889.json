{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ilyal\\\\OneDrive\\\\\\u0420\\u0430\\u0431\\u043E\\u0447\\u0438\\u0439 \\u0441\\u0442\\u043E\\u043B\\\\\\u05D1\\u05E8\\u05D0\\u05D5\\u05D3\\u05D4\\\\\\u05E1\\u05DE\\u05E1\\u05D8\\u05E8 8\\\\\\u05D0\\u05E7\\u05D5\\u05DC\\u05D5\\u05D2\\u05D9\\u05D4\\\\PlantTalk\\\\src\\\\contexts\\\\SensorContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/contexts/SensorContext.js\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { fetchSensorData, fetchSensorHistory } from '../services/sensorService';\nimport { usePlant } from './PlantContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SensorContext = /*#__PURE__*/createContext();\nexport const useSensor = () => {\n  _s();\n  const context = useContext(SensorContext);\n  if (!context) {\n    throw new Error('useSensor must be used within a SensorProvider');\n  }\n  return context;\n};\n_s(useSensor, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const SensorProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    updatePlantStatus\n  } = usePlant();\n  const [sensorData, setSensorData] = useState({\n    soilMoisture: 45,\n    // percentage\n    temperature: 72,\n    // Fahrenheit\n    humidity: 55,\n    // percentage\n    light: 65,\n    // percentage\n    lastUpdated: new Date()\n  });\n  const [sensorHistory, setSensorHistory] = useState([\n  // Initial history data - in a real app this would come from an API\n  {\n    timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),\n    soilMoisture: 75,\n    temperature: 72,\n    humidity: 60,\n    light: 70\n  }, {\n    timestamp: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000),\n    soilMoisture: 68,\n    temperature: 73,\n    humidity: 58,\n    light: 65\n  }, {\n    timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),\n    soilMoisture: 60,\n    temperature: 74,\n    humidity: 55,\n    light: 60\n  }, {\n    timestamp: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000),\n    soilMoisture: 52,\n    temperature: 73,\n    humidity: 54,\n    light: 68\n  }, {\n    timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000),\n    soilMoisture: 82,\n    temperature: 71,\n    humidity: 57,\n    light: 72\n  }, {\n    timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),\n    soilMoisture: 75,\n    temperature: 70,\n    humidity: 59,\n    light: 70\n  }, {\n    timestamp: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),\n    soilMoisture: 65,\n    temperature: 72,\n    humidity: 56,\n    light: 65\n  }]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Function to fetch latest sensor data\n  const refreshSensorData = () => {\n    try {\n      var _sensorHistory$;\n      setLoading(true);\n\n      // In a real application, this would fetch from an API\n      // const data = await fetchSensorData();\n      // setSensorData(data);\n\n      // For demo purposes, simulate changing sensor values\n      const newSoilMoisture = Math.max(5, sensorData.soilMoisture - Math.random() * 2);\n      const newTemperature = sensorData.temperature + (Math.random() * 2 - 1);\n      const newHumidity = Math.max(30, Math.min(80, sensorData.humidity + (Math.random() * 3 - 1.5)));\n      const newLight = Math.max(10, Math.min(90, sensorData.light + (Math.random() * 5 - 2.5)));\n      const newData = {\n        soilMoisture: Math.round(newSoilMoisture),\n        temperature: Math.round(newTemperature * 10) / 10,\n        humidity: Math.round(newHumidity),\n        light: Math.round(newLight),\n        lastUpdated: new Date()\n      };\n      setSensorData(newData);\n\n      // Add to history every few hours\n      const lastHistoryTimestamp = (_sensorHistory$ = sensorHistory[0]) === null || _sensorHistory$ === void 0 ? void 0 : _sensorHistory$.timestamp;\n      if (!lastHistoryTimestamp || new Date() - lastHistoryTimestamp > 3 * 60 * 60 * 1000) {\n        setSensorHistory(prev => [{\n          ...newData,\n          timestamp: new Date()\n        }, ...prev]);\n      }\n\n      // Update plant status based on new sensor data\n      updatePlantStatus(newData);\n      setLoading(false);\n    } catch (err) {\n      setError('Could not fetch sensor data');\n      setLoading(false);\n    }\n  };\n\n  // Calculate derived values\n  const getSensorTrends = () => {\n    if (sensorHistory.length < 2) return {\n      soilMoisture: 'stable',\n      temperature: 'stable',\n      humidity: 'stable',\n      light: 'stable'\n    };\n    const current = sensorHistory[0];\n    const previous = sensorHistory[1];\n    return {\n      soilMoisture: getTrend(current.soilMoisture, previous.soilMoisture),\n      temperature: getTrend(current.temperature, previous.temperature),\n      humidity: getTrend(current.humidity, previous.humidity),\n      light: getTrend(current.light, previous.light)\n    };\n  };\n  const getTrend = (current, previous) => {\n    const diff = current - previous;\n    if (Math.abs(diff) < 3) return 'stable';\n    return diff > 0 ? 'rising' : 'falling';\n  };\n  const calculateSoilMoistureDepletion = () => {\n    // Implement mechanistic model: dM/dt = -k · (T - Tbase) · (1 - H/100)\n    const k = 0.1; // Coefficient depending on soil type\n    const tBase = 50; // Base temperature in Fahrenheit\n\n    const depletionRate = -k * (sensorData.temperature - tBase) * (1 - sensorData.humidity / 100);\n\n    // Predict days until soil moisture reaches critical level (25%)\n    const daysUntilCritical = (sensorData.soilMoisture - 25) / (-depletionRate * 24);\n    return Math.max(0, Math.round(daysUntilCritical * 10) / 10);\n  };\n\n  // Set up regular refresh of sensor data\n  // FIXED: Removed sensorData values from dependency array to prevent infinite loop\n  useEffect(() => {\n    refreshSensorData();\n    const interval = setInterval(() => {\n      refreshSensorData();\n    }, 30000); // Refresh every 30 seconds for demo\n\n    return () => clearInterval(interval);\n  }, []); // Empty dependency array means this only runs once on mount\n\n  // Value object to be provided to consumers\n  const value = {\n    sensorData,\n    sensorHistory,\n    loading,\n    error,\n    refreshSensorData,\n    trends: getSensorTrends(),\n    daysUntilWaterNeeded: calculateSoilMoistureDepletion()\n  };\n  return /*#__PURE__*/_jsxDEV(SensorContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 142,\n    columnNumber: 10\n  }, this);\n};\n_s2(SensorProvider, \"ZTeLbjc7u7UMVsmZx7wHj6xrWtU=\", false, function () {\n  return [usePlant];\n});\n_c = SensorProvider;\nexport default SensorContext;\nvar _c;\n$RefreshReg$(_c, \"SensorProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","fetchSensorData","fetchSensorHistory","usePlant","jsxDEV","_jsxDEV","SensorContext","useSensor","_s","context","Error","SensorProvider","children","_s2","updatePlantStatus","sensorData","setSensorData","soilMoisture","temperature","humidity","light","lastUpdated","Date","sensorHistory","setSensorHistory","timestamp","now","loading","setLoading","error","setError","refreshSensorData","_sensorHistory$","newSoilMoisture","Math","max","random","newTemperature","newHumidity","min","newLight","newData","round","lastHistoryTimestamp","prev","err","getSensorTrends","length","current","previous","getTrend","diff","abs","calculateSoilMoistureDepletion","k","tBase","depletionRate","daysUntilCritical","interval","setInterval","clearInterval","value","trends","daysUntilWaterNeeded","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/ilyal/OneDrive/Рабочий стол/בראודה/סמסטר 8/אקולוגיה/PlantTalk/src/contexts/SensorContext.js"],"sourcesContent":["// src/contexts/SensorContext.js\r\nimport React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { fetchSensorData, fetchSensorHistory } from '../services/sensorService';\r\nimport { usePlant } from './PlantContext';\r\n\r\nconst SensorContext = createContext();\r\n\r\nexport const useSensor = () => {\r\n  const context = useContext(SensorContext);\r\n  if (!context) {\r\n    throw new Error('useSensor must be used within a SensorProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport const SensorProvider = ({ children }) => {\r\n  const { updatePlantStatus } = usePlant();\r\n  \r\n  const [sensorData, setSensorData] = useState({\r\n    soilMoisture: 45, // percentage\r\n    temperature: 72, // Fahrenheit\r\n    humidity: 55, // percentage\r\n    light: 65, // percentage\r\n    lastUpdated: new Date(),\r\n  });\r\n  \r\n  const [sensorHistory, setSensorHistory] = useState([\r\n    // Initial history data - in a real app this would come from an API\r\n    { timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), soilMoisture: 75, temperature: 72, humidity: 60, light: 70 },\r\n    { timestamp: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000), soilMoisture: 68, temperature: 73, humidity: 58, light: 65 },\r\n    { timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000), soilMoisture: 60, temperature: 74, humidity: 55, light: 60 },\r\n    { timestamp: new Date(Date.now() - 4 * 24 * 60 * 60 * 1000), soilMoisture: 52, temperature: 73, humidity: 54, light: 68 },\r\n    { timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), soilMoisture: 82, temperature: 71, humidity: 57, light: 72 },\r\n    { timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), soilMoisture: 75, temperature: 70, humidity: 59, light: 70 },\r\n    { timestamp: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000), soilMoisture: 65, temperature: 72, humidity: 56, light: 65 },\r\n  ]);\r\n  \r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  // Function to fetch latest sensor data\r\n  const refreshSensorData = () => {\r\n    try {\r\n      setLoading(true);\r\n      \r\n      // In a real application, this would fetch from an API\r\n      // const data = await fetchSensorData();\r\n      // setSensorData(data);\r\n      \r\n      // For demo purposes, simulate changing sensor values\r\n      const newSoilMoisture = Math.max(5, sensorData.soilMoisture - Math.random() * 2);\r\n      const newTemperature = sensorData.temperature + (Math.random() * 2 - 1);\r\n      const newHumidity = Math.max(30, Math.min(80, sensorData.humidity + (Math.random() * 3 - 1.5)));\r\n      const newLight = Math.max(10, Math.min(90, sensorData.light + (Math.random() * 5 - 2.5)));\r\n      \r\n      const newData = {\r\n        soilMoisture: Math.round(newSoilMoisture),\r\n        temperature: Math.round(newTemperature * 10) / 10,\r\n        humidity: Math.round(newHumidity),\r\n        light: Math.round(newLight),\r\n        lastUpdated: new Date(),\r\n      };\r\n      \r\n      setSensorData(newData);\r\n      \r\n      // Add to history every few hours\r\n      const lastHistoryTimestamp = sensorHistory[0]?.timestamp;\r\n      if (!lastHistoryTimestamp || (new Date() - lastHistoryTimestamp) > 3 * 60 * 60 * 1000) {\r\n        setSensorHistory(prev => [\r\n          { ...newData, timestamp: new Date() },\r\n          ...prev\r\n        ]);\r\n      }\r\n      \r\n      // Update plant status based on new sensor data\r\n      updatePlantStatus(newData);\r\n      \r\n      setLoading(false);\r\n    } catch (err) {\r\n      setError('Could not fetch sensor data');\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Calculate derived values\r\n  const getSensorTrends = () => {\r\n    if (sensorHistory.length < 2) return { soilMoisture: 'stable', temperature: 'stable', humidity: 'stable', light: 'stable' };\r\n    \r\n    const current = sensorHistory[0];\r\n    const previous = sensorHistory[1];\r\n    \r\n    return {\r\n      soilMoisture: getTrend(current.soilMoisture, previous.soilMoisture),\r\n      temperature: getTrend(current.temperature, previous.temperature),\r\n      humidity: getTrend(current.humidity, previous.humidity),\r\n      light: getTrend(current.light, previous.light)\r\n    };\r\n  };\r\n  \r\n  const getTrend = (current, previous) => {\r\n    const diff = current - previous;\r\n    if (Math.abs(diff) < 3) return 'stable';\r\n    return diff > 0 ? 'rising' : 'falling';\r\n  };\r\n\r\n  const calculateSoilMoistureDepletion = () => {\r\n    // Implement mechanistic model: dM/dt = -k · (T - Tbase) · (1 - H/100)\r\n    const k = 0.1; // Coefficient depending on soil type\r\n    const tBase = 50; // Base temperature in Fahrenheit\r\n    \r\n    const depletionRate = -k * (sensorData.temperature - tBase) * (1 - sensorData.humidity / 100);\r\n    \r\n    // Predict days until soil moisture reaches critical level (25%)\r\n    const daysUntilCritical = (sensorData.soilMoisture - 25) / (-depletionRate * 24);\r\n    \r\n    return Math.max(0, Math.round(daysUntilCritical * 10) / 10);\r\n  };\r\n\r\n  // Set up regular refresh of sensor data\r\n  // FIXED: Removed sensorData values from dependency array to prevent infinite loop\r\n  useEffect(() => {\r\n    refreshSensorData();\r\n    \r\n    const interval = setInterval(() => {\r\n      refreshSensorData();\r\n    }, 30000); // Refresh every 30 seconds for demo\r\n    \r\n    return () => clearInterval(interval);\r\n  }, []); // Empty dependency array means this only runs once on mount\r\n\r\n  // Value object to be provided to consumers\r\n  const value = {\r\n    sensorData,\r\n    sensorHistory,\r\n    loading,\r\n    error,\r\n    refreshSensorData,\r\n    trends: getSensorTrends(),\r\n    daysUntilWaterNeeded: calculateSoilMoistureDepletion(),\r\n  };\r\n\r\n  return <SensorContext.Provider value={value}>{children}</SensorContext.Provider>;\r\n};\r\n\r\nexport default SensorContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}